## Learning Objective(s):
Assembly language program structure  
* Directives, comments, mnemonics, labels, sections  
Data Aligning in ARM
## General Structure

**Each assembly statement can consist of three fields:**
* a label (identifier of the instruction)
* the key (an assembly instruction, or directive to assembler)
* a comment 
![[Pasted image 20241211131050.png]]
### Directives and Sections:
* Begin with a period
* Rest of name is composed of letters
* Instructs the GNU Assembler during its assembly process on:
	* Controlling the Sections  
	* Allocating space for Variables and Constants  
	* Setting and manipulating symbols  
	* Filling and Aligning memory space  
	* Conditional assembly  
	* Defining Macros

**Examples (sections):**
.data
.text
.bss
.section

**Examples (directives):**
.word
.asciz
.global *symbol* -> makes symbol visible to the linker
### Comments:
// for single line comment
/* \*/ for multi-line comment
### Mnemonics:
When statement begins with a letter, it is a regular assembly instruction, this is a mnemonic.

**Examples:**
add
mul
ldr
str
adr
### Labels:
A label is a name followed by a colon.
It uniquely identifies a given point or data item in the assembly program.

**Examples:**
main:
function:
end:
## All together (example):
![[Pasted image 20241211132604.png]]


## Data Alignment
We have some directives used for allocating space for variables and constants:
.byte (8-bit)
.hword (16-bit)
.word (32-bit)
.quad (64-bit)
.ascii (string with no NULL terminator)
.asciz or .string (string with a NULL terminator)
.float or .single (32-bit single precision floating point numbers)
.double (64-bit double precision floating point numbers)
.space *size* (allocates a size-byte space of memory)


### Aligning:
.align 3, 0 (Advances the location counter until it's a multiple of 8 and if the location counter is already a multiple of 8, no change is needed, If advance is successful, pads the advanced bytes with 0.)

.align 2, 0 (same thing with multiple of 4)

.align 1, 0 (same thing with multiple of 2)

In AArch64 assembly programming, proper data alignment is crucial for performance and correctness.  
**Alignment Requirements:**
* Halfword: Must be aligned to a 2-byte boundary (addresses that are multiples of 2).  
* Word: Must be aligned to a 4-byte boundary (addresses that are multiples of 4).  
* Double Word: Must be aligned to an 8-byte boundary (addresses that are multiples of 8).

Use the .align directive to ensure proper alignment in your assembly code.
* Will prevent potential alignment faults and ensure optimal access speed.

To not have to use align, declare your quads first, then words, then halfwords, then bytes, then strings.
![[Pasted image 20241211134019.png]]